import curses  
import RPi.GPIO as GPIO  
from datetime import datetime  
import Adafruit_DS3231  
  
# Konfiguration der GPIO-Pins  
LICHTSCHRANKE_PIN = 18  # Beispiel-PIN  
  
# RTC-Modul initialisieren  
rtc = Adafruit_DS3231.DS3231()  
  
# GPIO-Setup  
GPIO.setmode(GPIO.BCM)  
GPIO.setup(LICHTSCHRANKE_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)  
  
start_time = None  
stop_time = None  
elapsed_time = None  
  
def lichtschranke_callback(channel):  
    global start_time, stop_time, elapsed_time  
    if start_time is None:  
        start_time = rtc.read_datetime()  
    else:  
        stop_time = rtc.read_datetime()  
        elapsed_time = (stop_time - start_time).total_seconds()  
        start_time = None  # Reset for the next round  
  
# GPIO-Event-Setup  
GPIO.add_event_detect(LICHTSCHRANKE_PIN, GPIO.FALLING, callback=lichtschranke_callback, bouncetime=300)  
  
def main(stdscr):  
    global elapsed_time  
  
    # Curses-Setup  
    curses.curs_set(0)  # Cursor ausblenden  
    stdscr.nodelay(1)   # Non-blocking input  
    stdscr.timeout(100) # Refresh alle 100 ms  
  
    while True:  
        stdscr.clear()  
        stdscr.border(0)  
          
        stdscr.addstr(2, 2, "Kartrennen Zeitnahme", curses.A_BOLD)  
          
        if elapsed_time is not None:  
            stdscr.addstr(5, 2, f'Rundenzeit: {elapsed_time:.2f} s')  
        else:  
            stdscr.addstr(5, 2, 'Warte auf Rundenzeit...')  
  
        stdscr.addstr(8, 2, "Drücke 'r' zum Zurücksetzen")  
        stdscr.addstr(10, 2, "Drücke 'q' zum Beenden")  
          
        # Eingabe verarbeiten  
        key = stdscr.getch()  
        if key == ord('q'):  
            break  
        elif key == ord('r'):  
            elapsed_time = None  
          
        stdscr.refresh()  
  
    GPIO.cleanup()  
  
# Start der curses-Anwendung  
curses.wrapper(main)  
